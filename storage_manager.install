<?php

/**
 * @file
 * Install, update, and uninstall functions for the Storage Manager module.
 */

use Drupal\Core\Config\FileStorage;
use Drupal\Core\Extension\ModuleInstallException;
use Drupal\taxonomy\Entity\Term;

/**
 * Implements hook_install().
 *
 * Sets the initial schema version.
 */
function storage_manager_install() {
  // Set the initial schema version.
  \Drupal::service('keyvalue')->get('system.schema')->set('storage_manager', 10001);

  $voc_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary');
  $required = ['storage_area', 'storage_type'];
  $missing = [];
  foreach ($required as $vid) {
    if (!$voc_storage->load($vid)) {
      $missing[] = $vid;
    }
  }

  if ($missing) {
    throw new ModuleInstallException(t('Storage Manager requires the vocabularies: @vocabularies. Please create them (Structure Â» Taxonomy) before enabling the module.', ['@vocabularies' => implode(', ', $missing)]));
  }

  _storage_manager_ensure_default_config();

  // Seed the storage areas.
  _storage_manager_seed_storage_areas();
  // Seed the storage types.
  _storage_manager_seed_storage_types();
}

/**
 * Implements hook_update_N().
 *
 * An empty update hook to set the initial schema version.
 */
function storage_manager_update_10001() {
  // This is an empty update hook to set the initial schema version.
  // No database changes are needed.
  return t('Storage Manager module schema updated to 10001.');
}

/**
 * Ensure default configuration exists after dependency adjustments.
 */
function storage_manager_update_10002() {
  _storage_manager_ensure_default_config();
  return t('Reinstalled missing Storage Manager configuration.');
}

/**
 * Seed common storage areas (safe to re-run).
 */
function _storage_manager_seed_storage_areas() {
  $vid = 'storage_area';
  $vocabulary = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($vid);
  if (!$vocabulary) {
    \Drupal::logger('storage_manager')->error('Unable to seed storage areas because the storage_area vocabulary is missing.');
    return;
  }
  $names = ['Metalshop', 'Studio', 'CNC Room'];
  foreach ($names as $name) {
    $exists = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->getQuery()
      ->condition('vid', $vid)
      ->condition('name', $name)
      ->accessCheck(FALSE)
      ->range(0, 1)
      ->execute();
    if (!$exists) {
      Term::create(['vid' => $vid, 'name' => $name])->save();
    }
  }
}

/**
 * Seed common storage types (safe to re-run).
 */
function _storage_manager_seed_storage_types() {
  $vid = 'storage_type';
  $vocabulary = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($vid);
  if (!$vocabulary) {
    \Drupal::logger('storage_manager')->error('Unable to seed storage types because the storage_type vocabulary is missing.');
    return;
  }
  $names = ['Small Bin', 'Large Bin'];
  foreach ($names as $name) {
    $exists = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->getQuery()
      ->condition('vid', $vid)
      ->condition('name', $name)
      ->accessCheck(FALSE)
      ->range(0, 1)
      ->execute();
    if (!$exists) {
      Term::create(['vid' => $vid, 'name' => $name])->save();
    }
  }
}

/**
 * Reinstalls any missing default configuration items for the module.
 */
function _storage_manager_ensure_default_config() {
  $config_storage = \Drupal::service('config.storage');
  $config_factory = \Drupal::configFactory();

  $module_path = \Drupal::service('extension.list.module')->getPath('storage_manager');
  $extension_storage = new FileStorage($module_path . '/config/optional');

  $config_items = [
    'eck.eck_entity_type.storage_assignment',
    'eck.eck_entity_type.storage_unit',
    'eck.eck_type.storage_assignment.storage_assignment',
    'eck.eck_type.storage_unit.storage_unit',
    'field.storage.storage_assignment.field_storage_assignment_status',
    'field.storage.storage_assignment.field_storage_end_date',
    'field.storage.storage_assignment.field_storage_issue_note',
    'field.storage.storage_assignment.field_storage_price_snapshot',
    'field.storage.storage_assignment.field_storage_start_date',
    'field.storage.storage_assignment.field_storage_stripe_sub_id',
    'field.storage.storage_assignment.field_storage_unit',
    'field.storage.storage_assignment.field_storage_user',
    'field.storage.storage_unit.field_storage_area',
    'field.storage.storage_unit.field_storage_note',
    'field.storage.storage_unit.field_storage_status',
    'field.storage.storage_unit.field_storage_type',
    'field.storage.storage_unit.field_storage_unit_id',
    'field.storage.taxonomy_term.field_monthly_price',
    'field.field.storage_assignment.storage_assignment.field_storage_assignment_status',
    'field.field.storage_assignment.storage_assignment.field_storage_end_date',
    'field.field.storage_assignment.storage_assignment.field_storage_issue_note',
    'field.field.storage_assignment.storage_assignment.field_storage_price_snapshot',
    'field.field.storage_assignment.storage_assignment.field_storage_start_date',
    'field.field.storage_assignment.storage_assignment.field_storage_stripe_sub_id',
    'field.field.storage_assignment.storage_assignment.field_storage_unit',
    'field.field.storage_assignment.storage_assignment.field_storage_user',
    'field.field.storage_unit.storage_unit.field_storage_area',
    'field.field.storage_unit.storage_unit.field_storage_note',
    'field.field.storage_unit.storage_unit.field_storage_status',
    'field.field.storage_unit.storage_unit.field_storage_type',
    'field.field.storage_unit.storage_unit.field_storage_unit_id',
    'field.field.taxonomy_term.storage_type.field_monthly_price',
    'core.entity_form_display.storage_assignment.storage_assignment.default',
    'core.entity_form_display.storage_unit.storage_unit.default',
    'core.entity_view_display.storage_assignment.storage_assignment.default',
    'core.entity_view_display.storage_unit.storage_unit.default',
    'taxonomy.vocabulary.storage_area',
    'taxonomy.vocabulary.storage_type',
  ];

  $missing = [];
  foreach ($config_items as $name) {
    if (!$config_storage->exists($name)) {
      $missing[] = $name;
    }
  }

  foreach ($missing as $name) {
    if ($extension_storage->exists($name)) {
      $data = $extension_storage->read($name);
      $config_factory->getEditable($name)->setData($data)->save(TRUE);
    }
  }
}

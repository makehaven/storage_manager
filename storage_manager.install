<?php

/**
 * @file
 * Install, update, and uninstall functions for the Storage Manager module.
 */

use Drupal\Core\Config\FileStorage;
use Drupal\Core\Config\MemoryStorage;
use Drupal\Core\Database\DatabaseExceptionWrapper;
use Drupal\Core\Entity\Entity\EntityFormDisplay;
use Drupal\Core\Entity\EntityDefinitionUpdateManagerInterface;
use Drupal\Core\Extension\ModuleInstallException;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\taxonomy\Entity\Term;

/**
 * Implements hook_install().
 *
 * Sets the initial schema version.
 */
function storage_manager_install() {
  // Set the initial schema version.
  \Drupal::service('keyvalue')->get('system.schema')->set('storage_manager', 10001);

  $voc_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary');
  $required = ['storage_area', 'storage_type'];
  $missing = [];
  foreach ($required as $vid) {
    if (!$voc_storage->load($vid)) {
      $missing[] = $vid;
    }
  }

  if ($missing) {
    throw new ModuleInstallException(t('Storage Manager requires the vocabularies: @vocabularies. Please create them (Structure Â» Taxonomy) before enabling the module.', ['@vocabularies' => implode(', ', $missing)]));
  }

  _storage_manager_ensure_default_config();

  // Seed the storage areas.
  _storage_manager_seed_storage_areas();
  // Seed the storage types.
  _storage_manager_seed_storage_types();
}

/**
 * Implements hook_update_N().
 *
 * An empty update hook to set the initial schema version.
 */
function storage_manager_update_10001() {
  // This is an empty update hook to set the initial schema version.
  // No database changes are needed.
  return t('Storage Manager module schema updated to 10001.');
}

/**
 * Ensure default configuration exists after dependency adjustments.
 */
function storage_manager_update_10002() {
  _storage_manager_ensure_default_config();
  return t('Reinstalled missing Storage Manager configuration.');
}

/**
 * Ensure new violation fields and pricing labels exist.
 */
function storage_manager_update_10003() {
  _storage_manager_ensure_default_config();

  $config = \Drupal::configFactory()->getEditable('field.field.taxonomy_term.storage_type.field_monthly_price');
  if ($config->get('label') !== 'Monthly Cost') {
    $config->set('label', 'Monthly Cost');
  }
  if ($config->get('description') === 'The monthly price for this type of storage.') {
    $config->set('description', 'The monthly cost for this type of storage.');
  }
  $config->save();

  $settings = \Drupal::configFactory()->getEditable('storage_manager.settings');
  if (!$settings->get('notifications.templates')) {
    $settings->set('notifications.enabled_events', ['assignment', 'release', 'violation_warning', 'violation_fine', 'violation_resolved']);
    $settings->set('notifications.templates', [
      'assignment' => [
        'subject' => 'Storage assignment confirmed for unit [unit_id]',
        'body' => "Hello [member_name],\n\nYou have been assigned storage unit [unit_id] ([storage_type]) starting [assignment_start]. The current monthly cost is $[monthly_cost].\n\nThanks,\n[site_name] team",
      ],
      'release' => [
        'subject' => 'Storage release confirmed for unit [unit_id]',
        'body' => "Hello [member_name],\n\nYour storage assignment for unit [unit_id] has ended effective [release_date].\n\nIf this is unexpected, please contact staff.",
      ],
      'violation_warning' => [
        'subject' => 'Storage violation recorded for unit [unit_id]',
        'body' => "Hello [member_name],\n\nA storage policy violation was recorded for unit [unit_id] on [violation_start]. A daily charge of $[violation_daily_rate] will accrue until the issue is resolved.\n\nPlease contact staff if you have questions.",
      ],
      'violation_fine' => [
        'subject' => 'Storage violation charges for unit [unit_id]',
        'body' => "Hello [member_name],\n\nThe storage violation for unit [unit_id] has accrued $[violation_total_due] in charges.\n\nPlease settle the balance with staff at your earliest convenience.",
      ],
      'violation_resolved' => [
        'subject' => 'Storage violation resolved for unit [unit_id]',
        'body' => "Hello [member_name],\n\nThe storage violation for unit [unit_id] was resolved on [violation_resolved]. Any outstanding balance is $[violation_total_due].\n\nThank you for your attention.",
      ],
    ]);
    $settings->save();
  }

  return t('Added violation tracking fields and updated storage pricing labels.');
}

/**
 * Reinstalls missing config entities and applies entity schema updates.
 */
function storage_manager_update_10004(&$sandbox) {
  _storage_manager_ensure_default_config();

  $applied = _storage_manager_apply_entity_definition_updates();
  if ($applied > 0) {
    return t('Reinstalled storage configuration and applied @count entity definition updates.', ['@count' => $applied]);
  }

  return t('Reinstalled storage configuration.');
}

/**
 * Ensure the updated storage type defaults exist with pricing.
 */
function storage_manager_update_10005() {
  _storage_manager_seed_storage_areas();
  _storage_manager_seed_storage_types();
  return t('Updated default storage type list and pricing.');
}

/**
 * Ensure the member release confirmation message exists.
 */
function storage_manager_update_10006() {
  $config = \Drupal::configFactory()->getEditable('storage_manager.settings');
  if (!$config->get('release_confirmation_message')) {
    $config->set('release_confirmation_message', 'I have totally cleaned out the storage area and removed my name. I understand I will be charged for cleanup and disposal if items are left or the storage area is in bad condition.');
    $config->save();
  }
  return t('Added default self-release confirmation statement.');
}

/**
 * Add complimentary flag to storage assignments.
 */
function storage_manager_update_10007() {
  $entity_type = 'storage_assignment';
  $field_name = 'field_storage_complimentary';

  if (!FieldStorageConfig::loadByName($entity_type, $field_name)) {
    FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => $entity_type,
      'type' => 'boolean',
      'cardinality' => 1,
      'settings' => [],
      'translatable' => FALSE,
    ])->save();
  }

  if (!FieldConfig::loadByName($entity_type, 'storage_assignment', $field_name)) {
    FieldConfig::create([
      'field_name' => $field_name,
      'entity_type' => $entity_type,
      'bundle' => 'storage_assignment',
      'label' => t('Complimentary assignment'),
      'description' => t('Mark when a storage assignment is provided at no cost.'),
      'required' => FALSE,
      'settings' => ['on_label' => t('Complimentary'), 'off_label' => t('Standard billing')],
    ])->save();
  }

  $settings = \Drupal::configFactory()->getEditable('storage_manager.settings');
  if ($settings->get('violation.default_daily_rate') === NULL) {
    $settings->set('violation.default_daily_rate', '0.00')->save();
  }

  return t('Added complimentary assignment flag.');
}

/**
 * Ensure violation financial fields exist on assignments.
 */
function storage_manager_update_10008() {
  $entity_type = 'storage_assignment';

  if (!FieldStorageConfig::loadByName($entity_type, 'field_violation_daily_rate')) {
    FieldStorageConfig::create([
      'field_name' => 'field_violation_daily_rate',
      'entity_type' => $entity_type,
      'type' => 'decimal',
      'cardinality' => 1,
      'settings' => [
        'precision' => 10,
        'scale' => 2,
      ],
      'translatable' => FALSE,
    ])->save();
  }

  if (!FieldConfig::loadByName($entity_type, 'storage_assignment', 'field_violation_daily_rate')) {
    FieldConfig::create([
      'field_name' => 'field_violation_daily_rate',
      'entity_type' => $entity_type,
      'bundle' => 'storage_assignment',
      'label' => t('Violation daily rate'),
      'description' => t('Daily charge applied while a violation remains active.'),
      'required' => FALSE,
    ])->save();
  }

  if (!FieldStorageConfig::loadByName($entity_type, 'field_violation_total_due')) {
    FieldStorageConfig::create([
      'field_name' => 'field_violation_total_due',
      'entity_type' => $entity_type,
      'type' => 'decimal',
      'cardinality' => 1,
      'settings' => [
        'precision' => 10,
        'scale' => 2,
      ],
      'translatable' => FALSE,
    ])->save();
  }

  if (!FieldConfig::loadByName($entity_type, 'storage_assignment', 'field_violation_total_due')) {
    FieldConfig::create([
      'field_name' => 'field_violation_total_due',
      'entity_type' => $entity_type,
      'bundle' => 'storage_assignment',
      'label' => t('Violation total due'),
      'description' => t('Finalized violation balance when the issue is resolved.'),
      'required' => FALSE,
    ])->save();
  }

  return t('Ensured violation financial fields exist.');
}

/**
 * Install configuration for dedicated storage violations.
 */
function storage_manager_update_10009() {
  _storage_manager_ensure_default_config();
  return t('Installed storage violation entity configuration.');
}

/**
 * Ensure storage violation fields exist.
 */
function storage_manager_update_10010() {
  _storage_manager_ensure_default_config();

  $entity_type = 'storage_violation';
  $fields = [
    'field_storage_vi_assignment' => [
      'type' => 'entity_reference',
      'settings' => ['target_type' => 'storage_assignment'],
      'required' => TRUE,
    ],
    'field_storage_vi_active' => [
      'type' => 'boolean',
      'settings' => ['on_label' => 'Active', 'off_label' => 'Resolved'],
      'required' => TRUE,
    ],
    'field_storage_vi_start' => [
      'type' => 'datetime',
      'settings' => ['datetime_type' => 'datetime'],
      'required' => TRUE,
    ],
    'field_storage_vi_resolved' => [
      'type' => 'datetime',
      'settings' => ['datetime_type' => 'datetime'],
      'required' => FALSE,
    ],
    'field_storage_vi_daily' => [
      'type' => 'decimal',
      'settings' => ['precision' => 10, 'scale' => 2],
      'required' => FALSE,
    ],
    'field_storage_vi_total' => [
      'type' => 'decimal',
      'settings' => ['precision' => 10, 'scale' => 2],
      'required' => FALSE,
    ],
    'field_storage_vi_note' => [
      'type' => 'string_long',
      'settings' => [],
      'required' => FALSE,
    ],
  ];

  foreach ($fields as $field_name => $info) {
    if (!FieldStorageConfig::loadByName($entity_type, $field_name)) {
      FieldStorageConfig::create([
        'field_name' => $field_name,
        'entity_type' => $entity_type,
        'type' => $info['type'],
        'settings' => $info['settings'],
        'cardinality' => 1,
        'translatable' => TRUE,
      ])->save();
    }

    if (!FieldConfig::loadByName($entity_type, 'storage_violation', $field_name)) {
      $config = [
        'field_name' => $field_name,
        'entity_type' => $entity_type,
        'bundle' => 'storage_violation',
        'label' => _storage_manager_humanize_violation_field($field_name),
        'required' => !empty($info['required']),
      ];
      if ($field_name === 'field_storage_vi_active') {
        $config['settings'] = ['on_label' => t('Active'), 'off_label' => t('Resolved')];
      }
      FieldConfig::create($config)->save();
    }
  }

  return t('Verified storage violation fields exist.');
}

function _storage_manager_humanize_violation_field(string $field_name): string {
  $map = [
    'field_storage_vi_assignment' => t('Related assignment'),
    'field_storage_vi_active' => t('Violation active'),
    'field_storage_vi_start' => t('Violation start'),
    'field_storage_vi_resolved' => t('Violation resolved'),
    'field_storage_vi_daily' => t('Daily rate'),
    'field_storage_vi_total' => t('Total due'),
    'field_storage_vi_note' => t('Notes'),
  ];
  return $map[$field_name] ?? t('Field');
}

/**
 * Seed common storage areas (safe to re-run).
 */
function _storage_manager_seed_storage_areas() {
  $vid = 'storage_area';
  $vocabulary = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($vid);
  if (!$vocabulary) {
    \Drupal::logger('storage_manager')->error('Unable to seed storage areas because the storage_area vocabulary is missing.');
    return;
  }
  $default_name = 'Basement Back Room';
  $exists = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->getQuery()
    ->condition('vid', $vid)
    ->condition('name', $default_name)
    ->accessCheck(FALSE)
    ->range(0, 1)
    ->execute();
  if (!$exists) {
    Term::create(['vid' => $vid, 'name' => $default_name])->save();
  }
}

/**
 * Seed common storage types (safe to re-run).
 */
function _storage_manager_seed_storage_types() {
  $vid = 'storage_type';
  $vocabulary = \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($vid);
  if (!$vocabulary) {
    \Drupal::logger('storage_manager')->error('Unable to seed storage types because the storage_type vocabulary is missing.');
    return;
  }
  $storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  $defaults = [
    [
      'name' => 'Vertical materials storage',
      'price' => '17.00',
    ],
    [
      'name' => "Standard Shelf 2' x 5' x 18\"",
      'price' => '22.00',
    ],
    [
      'name' => "Tall Shelf 2' x 5' x 30\"",
      'price' => '33.00',
    ],
    [
      'name' => 'Large Storage Bin',
      'price' => '12.00',
    ],
    [
      'name' => 'Small Storage Bin',
      'price' => '6.00',
    ],
    [
      'name' => 'Locker',
      'price' => '6.00',
    ],
    [
      'name' => 'Screen Slot Storage',
      'price' => '8.00',
    ],
    [
      'name' => 'Glass drawer',
      'price' => '6.00',
    ],
    [
      'name' => "3' x 4' Floor Space",
      'price' => '46.00',
    ],
    [
      'name' => "3' x 6' Floor Space",
      'price' => '60.00',
    ],
  ];

  foreach ($defaults as $default) {
    $query = $storage->getQuery()
      ->condition('vid', $vid)
      ->condition('name', $default['name'])
      ->accessCheck(FALSE)
      ->range(0, 1);
    $ids = $query->execute();

    if ($ids) {
      $term = $storage->load(reset($ids));
      if ($term && $term->hasField('field_monthly_price')) {
        $term->set('field_monthly_price', $default['price']);
        $term->save();
      }
      continue;
    }

    $values = [
      'vid' => $vid,
      'name' => $default['name'],
    ];
    /** @var \Drupal\taxonomy\Entity\Term $term */
    $term = Term::create($values);
    if ($term->hasField('field_monthly_price')) {
      $term->set('field_monthly_price', $default['price']);
    }
    $term->save();
  }
}

/**
 * Reinstalls any missing default configuration items for the module.
 */
function _storage_manager_ensure_default_config() {
  $config_factory = \Drupal::configFactory();
  $config_storage = \Drupal::service('config.storage');
  $config_manager = \Drupal::service('config.manager');
  $config_installer = \Drupal::service('config.installer');

  $module_path = \Drupal::service('extension.list.module')->getPath('storage_manager');
  $directories = [
    'install' => $module_path . '/config/install',
    'optional' => $module_path . '/config/optional',
  ];

  $simple_config = [];

  foreach ($directories as $directory => $path) {
    if (!is_dir($path)) {
      continue;
    }

    $source_storage = new FileStorage($path);
    $entity_memory = new MemoryStorage();

    foreach ($source_storage->listAll() as $config_name) {
      if ($config_storage->exists($config_name)) {
        continue;
      }

      if ($config_manager->getEntityTypeIdByName($config_name)) {
        $entity_memory->write($config_name, $source_storage->read($config_name));
      }
      else {
        $simple_config[$config_name] = $source_storage->read($config_name);
      }
    }

    if ($entity_memory->listAll()) {
      $config_installer->installOptionalConfig($entity_memory);
    }
  }

  foreach ($simple_config as $config_name => $data) {
    $config_factory->getEditable($config_name)->setData($data)->save(TRUE);
  }

  _storage_manager_apply_entity_definition_updates();

  $form_display = EntityFormDisplay::load('taxonomy_term.storage_type.default');
  if (!$form_display) {
    $form_display = EntityFormDisplay::create([
      'id' => 'taxonomy_term.storage_type.default',
      'targetEntityType' => 'taxonomy_term',
      'bundle' => 'storage_type',
      'mode' => 'default',
      'status' => TRUE,
    ]);
  }

  if ($form_display && !$form_display->getComponent('field_monthly_price')) {
    $form_display->setComponent('field_monthly_price', [
      'type' => 'number',
      'weight' => 5,
      'settings' => [
        'placeholder' => '',
        'min' => '',
        'max' => '',
        'prefix' => '',
        'suffix' => '',
      ],
      'third_party_settings' => [],
    ]);
    $form_display->save();
  }

  \Drupal::service('entity_type.manager')->clearCachedDefinitions();
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
}

/**
 * Applies any pending entity definition updates for storage entities.
 *
 * @return int
 *   The number of applied updates.
 */
function _storage_manager_apply_entity_definition_updates(): int {
  $update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_type_manager = \Drupal::entityTypeManager();
  $field_manager = \Drupal::service('entity_field.manager');
  $last_installed = \Drupal::service('entity.last_installed_schema.repository');

  $applied = 0;
  $change_list = $update_manager->getChangeList();

  foreach ($change_list as $entity_type_id => $changes) {
    if (!empty($changes['entity_type'])) {
      $entity_type_definition = $entity_type_manager->getDefinition($entity_type_id, FALSE);
      if ($entity_type_definition) {
        if ($changes['entity_type'] === EntityDefinitionUpdateManagerInterface::DEFINITION_CREATED) {
          $update_manager->installEntityType($entity_type_definition);
          $applied++;
        }
        elseif ($changes['entity_type'] === EntityDefinitionUpdateManagerInterface::DEFINITION_UPDATED) {
          $update_manager->updateEntityType($entity_type_definition);
          $applied++;
        }
      }
    }

    if (empty($changes['field_storage_definitions'])) {
      continue;
    }

    $field_definitions = $field_manager->getFieldStorageDefinitions($entity_type_id);
    $original_definitions = $last_installed->getLastInstalledFieldStorageDefinitions($entity_type_id);

    foreach ($changes['field_storage_definitions'] as $field_name => $change_type) {
      try {
        if ($change_type === EntityDefinitionUpdateManagerInterface::DEFINITION_CREATED && isset($field_definitions[$field_name])) {
          $definition = $field_definitions[$field_name];
          $update_manager->installFieldStorageDefinition($field_name, $entity_type_id, $definition->getProvider(), $definition);
          $applied++;
        }
        elseif ($change_type === EntityDefinitionUpdateManagerInterface::DEFINITION_UPDATED && isset($field_definitions[$field_name])) {
          $update_manager->updateFieldStorageDefinition($field_definitions[$field_name]);
          $applied++;
        }
        elseif ($change_type === EntityDefinitionUpdateManagerInterface::DEFINITION_DELETED && isset($original_definitions[$field_name])) {
          $update_manager->uninstallFieldStorageDefinition($original_definitions[$field_name]);
          $applied++;
        }
      }
      catch (DatabaseExceptionWrapper $exception) {
        if (str_contains($exception->getMessage(), 'Base table or view not found')) {
          \Drupal::logger('storage_manager')->warning('Skipped removing field %field from %entity because storage tables were missing.', [
            '%field' => $field_name,
            '%entity' => $entity_type_id,
          ]);
          continue;
        }
        throw $exception;
      }
    }
  }

  return $applied;
}
